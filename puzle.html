<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FerenPuzzle - Experiencia Premium</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&display=swap');
        
        body {
            background-color: #020617;
            color: #f8fafc;
            touch-action: none;
            overflow: hidden;
            font-family: 'Plus Jakarta Sans', sans-serif;
        }
        
        #main-layout {
            display: grid;
            grid-template-columns: 1fr 360px;
            height: calc(100vh - 80px);
        }

        @media (max-width: 1024px) {
            #main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 240px;
            }
        }

        #game-board {
            position: relative;
            background: #0f172a;
            background-image: radial-gradient(#1e293b 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
        }

        #puzzle-mat {
            position: absolute;
            background: rgba(255, 255, 255, 0.02);
            border: 2px dashed rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            pointer-events: none;
            display: none;
            z-index: 1;
        }

        #piece-tray {
            background-color: #020617;
            border-left: 1px solid #1e293b;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            align-content: flex-start;
            z-index: 60;
        }

        .piece-slot {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 6px;
        }

        #preview-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 4px solid #1e293b;
            border-radius: 8px;
            display: none;
            z-index: 5;
            overflow: hidden;
        }

        #source-image {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .puzzle-piece {
            position: absolute;
            cursor: grab;
            filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.6));
            touch-action: none;
            user-select: none;
            z-index: 10;
        }

        .puzzle-piece.in-tray {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) scale(var(--tray-scale)) !important;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 5;
        }

        .puzzle-piece.dragging {
            cursor: grabbing;
            z-index: 1000 !important;
            pointer-events: none;
            transform: scale(1.05) !important;
            filter: drop-shadow(10px 10px 15px rgba(0,0,0,0.8));
        }

        .puzzle-piece.solved {
            cursor: default;
            filter: brightness(1.05);
            z-index: 2 !important;
            pointer-events: none;
            transition: filter 0.5s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #818cf8 0%, #6366f1 100%);
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 700;
            color: white;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.5);
        }

        #ghost-image {
            position: absolute;
            opacity: 0.15;
            pointer-events: none;
            display: none;
            z-index: 1;
        }

        /* Logo Icon Style */
        .logo-icon {
            background: linear-gradient(45deg, #6366f1, #a855f7);
            mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,6H12V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V8A2,2,0,0,0,20,6ZM10,4V6H4V4ZM20,20H4V8H20Z"/></svg>') no-repeat center;
            -webkit-mask: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.5,8.5 L12.5,8.5 C13.3,8.5 14,9.2 14,10 L14,11 L15,11 C15.8,11 16.5,11.7 16.5,12.5 L16.5,13.5 C16.5,14.3 15.8,15 15,15 L14,15 L14,16 C14,16.8 13.3,17.5 12.5,17.5 L11.5,17.5 C10.7,17.5 10,16.8 10,16 L10,15 L9,15 C8.2,15 7.5,14.3 7.5,13.5 L7.5,12.5 C7.5,11.7 8.2,11 9,11 L10,11 L10,10 C10,9.2 10.7,8.5 11.5,8.5 Z" fill="black"/></svg>') no-repeat center;
        }

    </style>
</head>
<body>

    <header class="h-20 px-8 bg-slate-950/50 backdrop-blur-md flex items-center justify-between border-b border-slate-800/50 z-[100]">
        <div class="flex items-center gap-3">
            <div class="w-10 h-10 bg-indigo-600 rounded-xl flex items-center justify-center">
                <svg viewBox="0 0 24 24" class="w-6 h-6 text-white" fill="none" stroke="currentColor" stroke-width="3">
                    <path d="M7 10V9a4 4 0 014-4h2a4 4 0 014 4v1m2 4h.01M3 14h.01M12 18v.01" stroke-linecap="round"/>
                    <rect x="6" y="10" width="12" height="10" rx="2"/>
                </svg>
            </div>
            <h1 class="font-extrabold text-xl tracking-tighter">FEREN<span class="text-indigo-400">PUZZLE</span></h1>
        </div>

        <div class="flex-1 max-w-lg mx-6 flex items-center bg-slate-900/80 rounded-2xl border border-slate-700/50 px-4 py-1.5 focus-within:border-indigo-500/50 transition-colors">
            <input id="prompt-input" type="text" placeholder="IA: Un paisaje cyberpunk..." class="bg-transparent border-none outline-none w-full text-sm py-2 text-slate-200 placeholder:text-slate-500">
            
            <!-- BotÃ³n de subir archivo local -->
            <label for="file-input" class="p-2 text-slate-400 hover:text-indigo-400 cursor-pointer transition" title="Subir imagen propia">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </label>
            <input type="file" id="file-input" class="hidden" accept="image/*">

            <div class="w-px h-6 bg-slate-700 mx-2"></div>
            <button id="generate-btn" class="text-indigo-400 font-bold text-xs px-2 hover:text-white transition uppercase tracking-widest">Crear</button>
            <button id="random-btn" class="p-2 text-slate-400 hover:text-white transition" title="Imagen aleatoria">ðŸŽ²</button>
        </div>

        <div class="flex items-center gap-4">
            <select id="piece-count" class="bg-slate-900 text-slate-200 text-xs font-bold border border-slate-700 rounded-xl px-4 py-2.5 outline-none hover:bg-slate-800 transition">
                <option value="12">12 Piezas</option>
                <option value="24">24 Piezas</option>
                <option value="48">48 Piezas</option>
                <option value="80">80 Piezas</option>
                <option value="150">150 Piezas</option>
                <option value="300">300 Piezas</option>
                <option value="500">500 Piezas</option>
                <option value="1000" selected>1000 Piezas</option>
            </select>
            <button id="preview-btn" class="w-11 h-11 flex items-center justify-center bg-slate-800 rounded-xl text-slate-300 hover:bg-slate-700 transition" title="Ver original">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
            </button>
            <button id="reset-btn" class="p-2 text-slate-500 hover:text-red-400 transition" title="Reiniciar">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </button>
        </div>
    </header>

    <div id="main-layout">
        <main id="game-board">
            <div id="loading-overlay" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-slate-950/90 z-[110]">
                <div class="w-12 h-12 border-4 border-indigo-500/20 border-t-indigo-500 rounded-full animate-spin mb-4"></div>
                <p class="text-indigo-400 font-bold text-xs uppercase tracking-widest animate-pulse">Procesando imagen...</p>
            </div>

            <div id="puzzle-mat"></div>

            <div id="preview-container">
                <img id="source-image" alt="Puzle">
                <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-slate-950/40 backdrop-blur-sm">
                    <button id="start-btn" class="btn-primary scale-110">COMENZAR PUZZLE</button>
                </div>
            </div>

            <img id="ghost-image" alt="GuÃ­a">
        </main>

        <aside id="piece-tray"></aside>
    </div>

    <footer class="h-10 bg-slate-950 px-8 border-t border-slate-900 flex items-center justify-between text-[10px] font-bold text-slate-500 uppercase tracking-widest">
        <div id="status">FerenPuzzle v2.0 â€¢ Studio Edition</div>
        <div id="score" class="text-indigo-400">Progreso: 0%</div>
    </footer>

    <script>
        const apiKey = "";
        const gameBoard = document.getElementById('game-board');
        const pieceTray = document.getElementById('piece-tray');
        const puzzleMat = document.getElementById('puzzle-mat');
        const previewContainer = document.getElementById('preview-container');
        const startOverlay = document.getElementById('start-overlay');
        const sourceImage = document.getElementById('source-image');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const ghostImage = document.getElementById('ghost-image');
        const loadingOverlay = document.getElementById('loading-overlay');
        const statusText = document.getElementById('status');
        const scoreText = document.getElementById('score');
        const fileInput = document.getElementById('file-input');

        let currentImage = new Image();
        let pieces = [];
        let selectedPiece = null;
        let dragOffset = { x: 0, y: 0 };
        let config = { cols: 0, rows: 0, pW: 0, pH: 0, tab: 0, drawW: 0, drawH: 0 };
        let gridTabs = { h: [], v: [] };
        let trayPieceScale = 1.0;

        const tabPath = [
            { c: 'l', x: 35, y: 0 },
            { c: 'b', c1x: 35, c1y: -15, c2x: 25, c2y: -25, x: 50, y: -25 },
            { c: 'b', c1x: 75, c1y: -25, c2x: 65, c2y: -15, x: 65, y: 0 },
            { c: 'l', x: 100, y: 0 }
        ];

        window.onload = () => {
            setupEvents();
            loadRandom();
        };

        function setupEvents() {
            document.getElementById('random-btn').onclick = loadRandom;
            document.getElementById('generate-btn').onclick = () => generateIA(document.getElementById('prompt-input').value);
            startBtn.onclick = startPuzzle;
            resetBtn.onclick = () => { if (currentImage.src) initImage(currentImage.src); };
            
            // LÃ³gica de archivo local
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => initImage(event.target.result);
                reader.readAsDataURL(file);
            };

            window.addEventListener('mousedown', handlePointerDown);
            window.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('mouseup', handlePointerUp);
            
            window.addEventListener('touchstart', e => handlePointerDown(e.touches[0]), {passive: false});
            window.addEventListener('touchmove', e => { if(selectedPiece) { e.preventDefault(); handlePointerMove(e.touches[0]); } }, {passive: false});
            window.addEventListener('touchend', e => handlePointerUp(e.changedTouches[0]));

            const pBtn = document.getElementById('preview-btn');
            pBtn.onmousedown = () => ghostImage.style.display = 'block';
            pBtn.onmouseup = () => ghostImage.style.display = 'none';
        }

        function showLoading(show) {
            loadingOverlay.classList.toggle('hidden', !show);
        }

        async function generateIA(prompt) {
            if (!prompt) return;
            showLoading(true);
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ instances: [{ prompt }], parameters: { sampleCount: 1 } })
                });
                const data = await res.json();
                if (data.predictions?.[0]?.bytesBase64Encoded) {
                    initImage(`data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`);
                }
            } catch (e) { statusText.innerText = "Error de IA"; }
            finally { showLoading(false); }
        }

        function loadRandom() {
            showLoading(true);
            const id = Math.floor(Math.random() * 1000);
            initImage(`https://picsum.photos/id/${id}/1200/800`);
        }

        function initImage(src) {
            resetGame();
            currentImage = new Image();
            currentImage.crossOrigin = "anonymous";
            currentImage.src = src;
            currentImage.onload = () => {
                calculateDimensions();
                previewContainer.style.display = 'block';
                startOverlay.style.display = 'flex';
                sourceImage.src = src;
                showLoading(false);
                statusText.innerText = "Imagen cargada. Selecciona piezas y empieza.";
            };
        }

        function resetGame() {
            pieceTray.innerHTML = '';
            pieces = [];
            gameBoard.querySelectorAll('.puzzle-piece').forEach(p => p.remove());
            ghostImage.style.display = 'none';
            puzzleMat.style.display = 'none';
            scoreText.innerText = "Progreso: 0%";
            previewContainer.style.display = 'none';
        }

        function calculateDimensions() {
            const margin = 120;
            const containerW = gameBoard.clientWidth - margin;
            const containerH = gameBoard.clientHeight - margin;
            const imgRatio = currentImage.width / currentImage.height;

            let w, h;
            if (containerW / containerH > imgRatio) {
                h = containerH;
                w = h * imgRatio;
            } else {
                w = containerW;
                h = w / imgRatio;
            }

            config.drawW = w;
            config.drawH = h;
            previewContainer.style.width = w + 'px';
            previewContainer.style.height = h + 'px';

            puzzleMat.style.width = w + 'px';
            puzzleMat.style.height = h + 'px';
            puzzleMat.style.left = ((gameBoard.clientWidth - w) / 2) + 'px';
            puzzleMat.style.top = ((gameBoard.clientHeight - h) / 2) + 'px';
        }

        function startPuzzle() {
            startOverlay.style.display = 'none';
            const total = parseInt(document.getElementById('piece-count').value);
            const ratio = config.drawW / config.drawH;
            config.cols = Math.round(Math.sqrt(total * ratio));
            config.rows = Math.round(total / config.cols);
            config.pW = config.drawW / config.cols;
            config.pH = config.drawH / config.rows;
            config.tab = Math.min(config.pW, config.pH) * 0.25;

            const trayColWidth = (pieceTray.clientWidth / 10) - 6; 
            const pieceMaxDim = Math.max(config.pW, config.pH) + (config.tab * 3);
            trayPieceScale = trayColWidth / pieceMaxDim;

            gridTabs.h = Array.from({length: config.rows - 1}, () => 
                Array.from({length: config.cols}, () => Math.random() < 0.5 ? 1 : -1));
            gridTabs.v = Array.from({length: config.rows}, () => 
                Array.from({length: config.cols - 1}, () => Math.random() < 0.5 ? 1 : -1));

            createPieces();
            previewContainer.style.display = 'none';
            puzzleMat.style.display = 'block';
            setupGhost();
        }

        function createPieces() {
            const bleed = config.tab * 1.5;
            let piecesData = [];
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    piecesData.push({r, c});
                }
            }
            piecesData.sort(() => Math.random() - 0.5);

            piecesData.forEach(data => {
                const piece = createPieceCanvas(data.r, data.c, bleed);
                const slot = document.createElement('div');
                slot.className = 'piece-slot';
                slot.appendChild(piece.el);
                pieceTray.appendChild(slot);
                pieces.push(piece);
            });
        }

        function createPieceCanvas(r, c, bleed) {
            const canvas = document.createElement('canvas');
            const w = config.pW + bleed * 2;
            const h = config.pH + bleed * 2;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            ctx.beginPath();
            const x = bleed;
            const y = bleed;

            ctx.moveTo(x, y);
            if (r === 0) ctx.lineTo(x + config.pW, y);
            else drawSegment(ctx, x, y, x + config.pW, y, -gridTabs.h[r-1][c]);

            if (c === config.cols - 1) ctx.lineTo(x + config.pW, y + config.pH);
            else drawSegment(ctx, x + config.pW, y, x + config.pW, y + config.pH, gridTabs.v[r][c]);

            if (r === config.rows - 1) ctx.lineTo(x, y + config.pH);
            else drawSegment(ctx, x + config.pW, y + config.pH, x, y + config.pH, gridTabs.h[r][c]);

            if (c === 0) ctx.lineTo(x, y);
            else drawSegment(ctx, x, y + config.pH, x, y, -gridTabs.v[r][c-1]);

            ctx.closePath();
            ctx.clip();
            
            const sx = (c * currentImage.width / config.cols) - (bleed * currentImage.width / config.drawW);
            const sy = (r * currentImage.height / config.rows) - (bleed * currentImage.height / config.drawH);
            const sw = (currentImage.width / config.cols) + (bleed * 2 * currentImage.width / config.drawW);
            const sh = (currentImage.height / config.rows) + (bleed * 2 * currentImage.height / config.drawH);
            
            ctx.drawImage(currentImage, sx, sy, sw, sh, 0, 0, w, h);
            ctx.strokeStyle = "rgba(255,255,255,0.2)";
            ctx.lineWidth = 1;
            ctx.stroke();

            canvas.classList.add('puzzle-piece', 'in-tray');
            canvas.style.setProperty('--tray-scale', trayPieceScale);

            return {
                el: canvas,
                r, c,
                targetX: ((gameBoard.clientWidth - config.drawW) / 2) + (c * config.pW) - bleed,
                targetY: ((gameBoard.clientHeight - config.drawH) / 2) + (r * config.pH) - bleed,
                solved: false,
                inTray: true
            };
        }

        function drawSegment(ctx, x1, y1, x2, y2, tabType) {
            const dx = x2 - x1, dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const dist = Math.sqrt(dx * dx + dy * dy);
            const scale = dist / 100;
            const tabSize = config.tab;

            ctx.save();
            ctx.translate(x1, y1);
            ctx.rotate(angle);
            ctx.lineTo(0, 0);
            if (tabType !== 0) {
                tabPath.forEach(p => {
                    const tx = p.x * scale;
                    const ty = p.y * (tabSize / 25) * tabType;
                    if (p.c === 'l') ctx.lineTo(tx, ty);
                    else if (p.c === 'b') {
                        ctx.bezierCurveTo(
                            p.c1x * scale, p.c1y * (tabSize / 25) * tabType,
                            p.c2x * scale, p.c2y * (tabSize / 25) * tabType,
                            tx, ty
                        );
                    }
                });
            } else ctx.lineTo(dist, 0);
            ctx.restore();
        }

        function setupGhost() {
            ghostImage.src = currentImage.src;
            ghostImage.style.width = config.drawW + 'px';
            ghostImage.style.height = config.drawH + 'px';
            ghostImage.style.left = puzzleMat.style.left;
            ghostImage.style.top = puzzleMat.style.top;
        }

        function handlePointerDown(e) {
            const el = e.target;
            if (!el.classList.contains('puzzle-piece')) return;
            const piece = pieces.find(p => p.el === el);
            if (piece.solved) return;

            selectedPiece = piece;
            const rect = el.getBoundingClientRect();
            const boardRect = gameBoard.getBoundingClientRect();

            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            if (piece.inTray) {
                piece.inTray = false;
                el.classList.remove('in-tray');
                el.classList.add('dragging');
                gameBoard.appendChild(el);
                el.style.left = (e.clientX - boardRect.left - dragOffset.x) + 'px';
                el.style.top = (e.clientY - boardRect.top - dragOffset.y) + 'px';
            } else {
                el.classList.add('dragging');
            }
        }

        function handlePointerMove(e) {
            if (!selectedPiece) return;
            const boardRect = gameBoard.getBoundingClientRect();
            selectedPiece.el.style.left = (e.clientX - boardRect.left - dragOffset.x) + 'px';
            selectedPiece.el.style.top = (e.clientY - boardRect.top - dragOffset.y) + 'px';
        }

        function handlePointerUp(e) {
            if (!selectedPiece) return;
            const el = selectedPiece.el;
            el.classList.remove('dragging');

            const trayRect = pieceTray.getBoundingClientRect();
            const isOverTray = e.clientX > trayRect.left;

            if (isOverTray) {
                returnToTray(selectedPiece);
            } else {
                const curX = parseFloat(el.style.left);
                const curY = parseFloat(el.style.top);
                const dist = Math.hypot(curX - selectedPiece.targetX, curY - selectedPiece.targetY);

                if (dist < 20) {
                    el.style.left = selectedPiece.targetX + 'px';
                    el.style.top = selectedPiece.targetY + 'px';
                    el.classList.add('solved');
                    selectedPiece.solved = true;
                    checkWin();
                }
            }
            selectedPiece = null;
        }

        function returnToTray(p) {
            p.inTray = true;
            const el = p.el;
            el.classList.add('in-tray');
            el.style.left = ""; el.style.top = "";
            const slots = Array.from(pieceTray.children);
            const emptySlot = slots.find(s => s.children.length === 0);
            if (emptySlot) emptySlot.appendChild(el);
            else {
                const newSlot = document.createElement('div');
                newSlot.className = 'piece-slot';
                newSlot.appendChild(el);
                pieceTray.appendChild(newSlot);
            }
        }

        function checkWin() {
            const solved = pieces.filter(p => p.solved).length;
            const pct = Math.round((solved / pieces.length) * 100);
            scoreText.innerText = `Progreso: ${pct}%`;
            if (pct === 100) statusText.innerText = "Â¡Enhorabuena! Puzle completado.";
        }
    </script>
</body>
</html>